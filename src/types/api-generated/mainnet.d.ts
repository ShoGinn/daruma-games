/**
 * This file was auto-generated by openapi-typescript.
 * Do not make direct changes to the file.
 */

export interface paths {
  '/genesis': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Gets the genesis information.
     * @description Returns the entire genesis file in json.
     */
    get: operations['GetGenesis'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/health': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** Returns OK if healthy. */
    get: operations['HealthCheck'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/metrics': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** Return metrics about algod functioning. */
    get: operations['Metrics'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/ready': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** Returns OK if healthy and fully caught up. */
    get: operations['GetReady'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/swagger.json': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Gets the current swagger spec.
     * @description Returns the entire swagger spec in json.
     */
    get: operations['SwaggerJSON'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/v2/accounts/{address}': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Get account information.
     * @description Given a specific account public key, this call returns the accounts status, balance and spendable amounts
     */
    get: operations['AccountInformation'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/v2/accounts/{address}/applications/{application-id}': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Get account information about a given app.
     * @description Given a specific account public key and application ID, this call returns the account's application local state and global state (AppLocalState and AppParams, if either exists). Global state will only be returned if the provided address is the application's creator.
     */
    get: operations['AccountApplicationInformation'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/v2/accounts/{address}/assets/{asset-id}': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Get account information about a given asset.
     * @description Given a specific account public key and asset ID, this call returns the account's asset holding and asset parameters (if either exist). Asset parameters will only be returned if the provided address is the asset's creator.
     */
    get: operations['AccountAssetInformation'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/v2/accounts/{address}/transactions/pending': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Get a list of unconfirmed transactions currently in the transaction pool by address.
     * @description Get the list of pending transactions by address, sorted by priority, in decreasing order, truncated at the end at MAX. If MAX = 0, returns all pending transactions.
     *
     */
    get: operations['GetPendingTransactionsByAddress'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/v2/applications/{application-id}': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Get application information.
     * @description Given a application ID, it returns application information including creator, approval and clear programs, global and local schemas, and global state.
     */
    get: operations['GetApplicationByID'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/v2/applications/{application-id}/box': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Get box information for a given application.
     * @description Given an application ID and box name, it returns the round, box name, and value (each base64 encoded). Box names must be in the goal app call arg encoding form 'encoding:value'. For ints, use the form 'int:1234'. For raw bytes, use the form 'b64:A=='. For printable strings, use the form 'str:hello'. For addresses, use the form 'addr:XYZ...'.
     */
    get: operations['GetApplicationBoxByName'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/v2/applications/{application-id}/boxes': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Get all box names for a given application.
     * @description Given an application ID, return all Box names. No particular ordering is guaranteed. Request fails when client or server-side configured limits prevent returning all Box names.
     */
    get: operations['GetApplicationBoxes'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/v2/assets/{asset-id}': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Get asset information.
     * @description Given a asset ID, it returns asset information including creator, name, total supply and special addresses.
     */
    get: operations['GetAssetByID'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/v2/blocks/{round}': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** Get the block for the given round. */
    get: operations['GetBlock'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/v2/blocks/{round}/hash': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** Get the block hash for the block on the given round. */
    get: operations['GetBlockHash'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/v2/blocks/{round}/lightheader/proof': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** Gets a proof for a given light block header inside a state proof commitment */
    get: operations['GetLightBlockHeaderProof'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/v2/blocks/{round}/transactions/{txid}/proof': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** Get a proof for a transaction in a block. */
    get: operations['GetTransactionProof'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/v2/catchup/{catchpoint}': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Starts a catchpoint catchup.
     * @description Given a catchpoint, it starts catching up to this catchpoint
     */
    post: operations['StartCatchup'];
    /**
     * Aborts a catchpoint catchup.
     * @description Given a catchpoint, it aborts catching up to this catchpoint
     */
    delete: operations['AbortCatchup'];
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/v2/deltas/txn/group/{id}': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Get a LedgerStateDelta object for a given transaction group
     * @description Get a ledger delta for a given transaction group.
     */
    get: operations['GetLedgerStateDeltaForTransactionGroup'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/v2/deltas/{round}': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Get a LedgerStateDelta object for a given round
     * @description Get ledger deltas for a round.
     */
    get: operations['GetLedgerStateDelta'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/v2/deltas/{round}/txn/group': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Get LedgerStateDelta objects for all transaction groups in a given round
     * @description Get ledger deltas for transaction groups in a given round.
     */
    get: operations['GetTransactionGroupLedgerStateDeltasForRound'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/v2/devmode/blocks/offset': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Returns the timestamp offset. Timestamp offsets can only be set in dev mode.
     * @description Gets the current timestamp offset.
     */
    get: operations['GetBlockTimeStampOffset'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/v2/devmode/blocks/offset/{offset}': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Given a timestamp offset in seconds, adds the offset to every subsequent block header's timestamp.
     * @description Sets the timestamp offset (seconds) for blocks in dev mode. Providing an offset of 0 will unset this value and try to use the real clock for the timestamp.
     */
    post: operations['SetBlockTimeStampOffset'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/v2/experimental': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** Returns OK if experimental API is enabled. */
    get: operations['ExperimentalCheck'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/v2/ledger/supply': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** Get the current supply reported by the ledger. */
    get: operations['GetSupply'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/v2/ledger/sync': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Returns the minimum sync round the ledger is keeping in cache.
     * @description Gets the minimum sync round for the ledger.
     */
    get: operations['GetSyncRound'];
    put?: never;
    post?: never;
    /**
     * Removes minimum sync round restriction from the ledger.
     * @description Unset the ledger sync round.
     */
    delete: operations['UnsetSyncRound'];
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/v2/ledger/sync/{round}': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Given a round, tells the ledger to keep that round in its cache.
     * @description Sets the minimum sync round on the ledger.
     */
    post: operations['SetSyncRound'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/v2/participation': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Return a list of participation keys
     * @description Return a list of participation keys
     */
    get: operations['GetParticipationKeys'];
    put?: never;
    /** Add a participation key to the node */
    post: operations['AddParticipationKey'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/v2/participation/{participation-id}': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Get participation key info given a participation ID
     * @description Given a participation ID, return information about that participation key
     */
    get: operations['GetParticipationKeyByID'];
    put?: never;
    /**
     * Append state proof keys to a participation key
     * @description Given a participation ID, append state proof keys to a particular set of participation keys
     */
    post: operations['AppendKeys'];
    /**
     * Delete a given participation key by ID
     * @description Delete a given participation key by ID
     */
    delete: operations['DeleteParticipationKeyByID'];
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/v2/shutdown': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /** @description Special management endpoint to shutdown the node. Optionally provide a timeout parameter to indicate that the node should begin shutting down after a number of seconds. */
    post: operations['ShutdownNode'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/v2/stateproofs/{round}': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** Get a state proof that covers a given round */
    get: operations['GetStateProof'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/v2/status': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** Gets the current node status. */
    get: operations['GetStatus'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/v2/status/wait-for-block-after/{round}': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Gets the node status after waiting for a round after the given round.
     * @description Waits for a block to appear after round {round} and returns the node's status at the time.
     */
    get: operations['WaitForBlock'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/v2/teal/compile': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Compile TEAL source code to binary, produce its hash
     * @description Given TEAL source code in plain text, return base64 encoded program bytes and base32 SHA512_256 hash of program bytes (Address style). This endpoint is only enabled when a node's configuration file sets EnableDeveloperAPI to true.
     */
    post: operations['TealCompile'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/v2/teal/disassemble': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Disassemble program bytes into the TEAL source code.
     * @description Given the program bytes, return the TEAL source code in plain text. This endpoint is only enabled when a node's configuration file sets EnableDeveloperAPI to true.
     */
    post: operations['TealDisassemble'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/v2/teal/dryrun': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Provide debugging information for a transaction (or group).
     * @description Executes TEAL program(s) in context and returns debugging information about the execution. This endpoint is only enabled when a node's configuration file sets EnableDeveloperAPI to true.
     */
    post: operations['TealDryrun'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/v2/transactions': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /** Broadcasts a raw transaction or transaction group to the network. */
    post: operations['RawTransaction'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/v2/transactions/params': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** Get parameters for constructing a new transaction */
    get: operations['TransactionParams'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/v2/transactions/pending': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Get a list of unconfirmed transactions currently in the transaction pool.
     * @description Get the list of pending transactions, sorted by priority, in decreasing order, truncated at the end at MAX. If MAX = 0, returns all pending transactions.
     *
     */
    get: operations['GetPendingTransactions'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/v2/transactions/pending/{txid}': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Get a specific pending transaction.
     * @description Given a transaction ID of a recently submitted transaction, it returns information about it.  There are several cases when this might succeed:
     *     - transaction committed (committed round > 0)
     *     - transaction still in the pool (committed round = 0, pool error = "")
     *     - transaction removed from pool due to error (committed round = 0, pool error != "")
     *     Or the transaction may have happened sufficiently long ago that the node no longer remembers it, and this will return an error.
     *
     */
    get: operations['PendingTransactionInformation'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/v2/transactions/simulate': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /** Simulates a raw transaction or transaction group as it would be evaluated on the network. The simulation will use blockchain state from the latest committed round. */
    post: operations['SimulateTransaction'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/versions': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** @description Retrieves the supported API versions, binary build versions, and genesis information. */
    get: operations['GetVersion'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
}
export type webhooks = Record<string, never>;
export interface components {
  schemas: {
    /** @description Account information at a given round.
     *
     *     Definition:
     *     data/basics/userBalance.go : AccountData
     *      */
    Account: {
      /** @description the account public key */
      address: string;
      /** @description \[algo\] total number of MicroAlgos in the account */
      amount: number;
      /** @description specifies the amount of MicroAlgos in the account, without the pending rewards. */
      'amount-without-pending-rewards': number;
      /** @description \[appl\] applications local data stored in this account.
       *
       *     Note the raw object uses `map[int] -> AppLocalState` for this type. */
      'apps-local-state'?: Array<components['schemas']['ApplicationLocalState']>;
      /** @description \[teap\] the sum of all extra application program pages for this account. */
      'apps-total-extra-pages'?: number;
      'apps-total-schema'?: components['schemas']['ApplicationStateSchema'];
      /** @description \[asset\] assets held by this account.
       *
       *     Note the raw object uses `map[int] -> AssetHolding` for this type. */
      assets?: Array<components['schemas']['AssetHolding']>;
      /** @description \[spend\] the address against which signing should be checked. If empty, the address of the current account is used. This field can be updated in any transaction by setting the RekeyTo field. */
      'auth-addr'?: string;
      /** @description \[appp\] parameters of applications created by this account including app global data.
       *
       *     Note: the raw account uses `map[int] -> AppParams` for this type. */
      'created-apps'?: Array<components['schemas']['Application']>;
      /** @description \[apar\] parameters of assets created by this account.
       *
       *     Note: the raw account uses `map[int] -> Asset` for this type. */
      'created-assets'?: Array<components['schemas']['Asset']>;
      /** @description MicroAlgo balance required by the account.
       *
       *     The requirement grows based on asset and application usage. */
      'min-balance': number;
      participation?: components['schemas']['AccountParticipation'];
      /** @description amount of MicroAlgos of pending rewards in this account. */
      'pending-rewards': number;
      /** @description \[ebase\] used as part of the rewards computation. Only applicable to accounts which are participating. */
      'reward-base'?: number;
      /** @description \[ern\] total rewards of MicroAlgos the account has received, including pending rewards. */
      rewards: number;
      /** @description The round for which this information is relevant. */
      round: number;
      /**
       * @description Indicates what type of signature is used by this account, must be one of:
       *     * sig
       *     * msig
       *     * lsig
       * @enum {string}
       */
      'sig-type'?: 'sig' | 'msig' | 'lsig';
      /** @description \[onl\] delegation status of the account's MicroAlgos
       *     * Offline - indicates that the associated account is delegated.
       *     *  Online  - indicates that the associated account used as part of the delegation pool.
       *     *   NotParticipating - indicates that the associated account is neither a delegator nor a delegate. */
      status: string;
      /** @description The count of all applications that have been opted in, equivalent to the count of application local data (AppLocalState objects) stored in this account. */
      'total-apps-opted-in': number;
      /** @description The count of all assets that have been opted in, equivalent to the count of AssetHolding objects held by this account. */
      'total-assets-opted-in': number;
      /** @description \[tbxb\] The total number of bytes used by this account's app's box keys and values. */
      'total-box-bytes'?: number;
      /** @description \[tbx\] The number of existing boxes created by this account's app. */
      'total-boxes'?: number;
      /** @description The count of all apps (AppParams objects) created by this account. */
      'total-created-apps': number;
      /** @description The count of all assets (AssetParams objects) created by this account. */
      'total-created-assets': number;
    };
    /** @description AccountParticipation describes the parameters used by this account in consensus protocol. */
    AccountParticipation: {
      /**
       * Format: byte
       * @description \[sel\] Selection public key (if any) currently registered for this round.
       */
      'selection-participation-key': string;
      /**
       * Format: byte
       * @description \[stprf\] Root of the state proof key (if any)
       */
      'state-proof-key'?: string;
      /** @description \[voteFst\] First round for which this participation is valid. */
      'vote-first-valid': number;
      /** @description \[voteKD\] Number of subkeys in each batch of participation keys. */
      'vote-key-dilution': number;
      /** @description \[voteLst\] Last round for which this participation is valid. */
      'vote-last-valid': number;
      /**
       * Format: byte
       * @description \[vote\] root participation public key (if any) currently registered for this round.
       */
      'vote-participation-key': string;
    };
    /** @description Application state delta. */
    AccountStateDelta: {
      address: string;
      delta: components['schemas']['StateDelta'];
    };
    /** @description Application index and its parameters */
    Application: {
      /** @description \[appidx\] application index. */
      id: number;
      params: components['schemas']['ApplicationParams'];
    };
    /** @description Stores local state associated with an application. */
    ApplicationLocalState: {
      /** @description The application which this local state is for. */
      id: number;
      'key-value'?: components['schemas']['TealKeyValueStore'];
      schema: components['schemas']['ApplicationStateSchema'];
    };
    /** @description Stores the global information associated with an application. */
    ApplicationParams: {
      /**
       * Format: byte
       * @description \[approv\] approval program.
       */
      'approval-program': string;
      /**
       * Format: byte
       * @description \[clearp\] approval program.
       */
      'clear-state-program': string;
      /** @description The address that created this application. This is the address where the parameters and global state for this application can be found. */
      creator: string;
      /** @description \[epp\] the amount of extra program pages available to this app. */
      'extra-program-pages'?: number;
      'global-state'?: components['schemas']['TealKeyValueStore'];
      'global-state-schema'?: components['schemas']['ApplicationStateSchema'];
      'local-state-schema'?: components['schemas']['ApplicationStateSchema'];
    };
    /** @description Specifies maximums on the number of each type that may be stored. */
    ApplicationStateSchema: {
      /** @description \[nbs\] num of byte slices. */
      'num-byte-slice': number;
      /** @description \[nui\] num of uints. */
      'num-uint': number;
    };
    /** @description Specifies both the unique identifier and the parameters for an asset */
    Asset: {
      /** @description unique asset identifier */
      index: number;
      params: components['schemas']['AssetParams'];
    };
    /** @description Describes an asset held by an account.
     *
     *     Definition:
     *     data/basics/userBalance.go : AssetHolding */
    AssetHolding: {
      /** @description \[a\] number of units held. */
      amount: number;
      /** @description Asset ID of the holding. */
      'asset-id': number;
      /** @description \[f\] whether or not the holding is frozen. */
      'is-frozen': boolean;
    };
    /** @description AssetParams specifies the parameters for an asset.
     *
     *     \[apar\] when part of an AssetConfig transaction.
     *
     *     Definition:
     *     data/transactions/asset.go : AssetParams */
    AssetParams: {
      /** @description \[c\] Address of account used to clawback holdings of this asset.  If empty, clawback is not permitted. */
      clawback?: string;
      /** @description The address that created this asset. This is the address where the parameters for this asset can be found, and also the address where unwanted asset units can be sent in the worst case. */
      creator: string;
      /** @description \[dc\] The number of digits to use after the decimal point when displaying this asset. If 0, the asset is not divisible. If 1, the base unit of the asset is in tenths. If 2, the base unit of the asset is in hundredths, and so on. This value must be between 0 and 19 (inclusive). */
      decimals: number;
      /** @description \[df\] Whether holdings of this asset are frozen by default. */
      'default-frozen'?: boolean;
      /** @description \[f\] Address of account used to freeze holdings of this asset.  If empty, freezing is not permitted. */
      freeze?: string;
      /** @description \[m\] Address of account used to manage the keys of this asset and to destroy it. */
      manager?: string;
      /**
       * Format: byte
       * @description \[am\] A commitment to some unspecified asset metadata. The format of this metadata is up to the application.
       */
      'metadata-hash'?: string;
      /** @description \[an\] Name of this asset, as supplied by the creator. Included only when the asset name is composed of printable utf-8 characters. */
      name?: string;
      /**
       * Format: byte
       * @description Base64 encoded name of this asset, as supplied by the creator.
       */
      'name-b64'?: string;
      /** @description \[r\] Address of account holding reserve (non-minted) units of this asset. */
      reserve?: string;
      /** @description \[t\] The total number of units of this asset. */
      total: number;
      /** @description \[un\] Name of a unit of this asset, as supplied by the creator. Included only when the name of a unit of this asset is composed of printable utf-8 characters. */
      'unit-name'?: string;
      /**
       * Format: byte
       * @description Base64 encoded name of a unit of this asset, as supplied by the creator.
       */
      'unit-name-b64'?: string;
      /** @description \[au\] URL where more information about the asset can be retrieved. Included only when the URL is composed of printable utf-8 characters. */
      url?: string;
      /**
       * Format: byte
       * @description Base64 encoded URL where more information about the asset can be retrieved.
       */
      'url-b64'?: string;
    };
    /** @description Box name and its content. */
    Box: {
      /**
       * Format: byte
       * @description \[name\] box name, base64 encoded
       */
      name: string;
      /** @description The round for which this information is relevant */
      round: number;
      /**
       * Format: byte
       * @description \[value\] box value, base64 encoded.
       */
      value: string;
    };
    /** @description Box descriptor describes a Box. */
    BoxDescriptor: {
      /**
       * Format: byte
       * @description Base64 encoded box name
       */
      name: string;
    };
    /** BuildVersion contains the current algod build version information. */
    BuildVersion: {
      branch: string;
      /** Format: int64 */
      build_number: number;
      channel: string;
      commit_hash: string;
      /** Format: int64 */
      major: number;
      /** Format: int64 */
      minor: number;
    };
    /** @description Request data type for dryrun endpoint. Given the Transactions and simulated ledger state upload, run TEAL scripts and return debugging information. */
    DryrunRequest: {
      accounts: Array<components['schemas']['Account']>;
      apps: Array<components['schemas']['Application']>;
      /**
       * Format: int64
       * @description LatestTimestamp is available to some TEAL scripts. Defaults to the latest confirmed timestamp this algod is attached to.
       */
      'latest-timestamp': number;
      /** @description ProtocolVersion specifies a specific version string to operate under, otherwise whatever the current protocol of the network this algod is running in. */
      'protocol-version': string;
      /** @description Round is available to some TEAL scripts. Defaults to the current round on the network this algod is attached to. */
      round: number;
      sources: Array<components['schemas']['DryrunSource']>;
      txns: string[];
    };
    /** @description DryrunSource is TEAL source text that gets uploaded, compiled, and inserted into transactions or application state. */
    DryrunSource: {
      'app-index': number;
      /** @description FieldName is what kind of sources this is. If lsig then it goes into the transactions[this.TxnIndex].LogicSig. If approv or clearp it goes into the Approval Program or Clear State Program of application[this.AppIndex]. */
      'field-name': string;
      source: string;
      'txn-index': number;
    };
    /** @description Stores the TEAL eval step data */
    DryrunState: {
      /** @description Evaluation error if any */
      error?: string;
      /** @description Line number */
      line: number;
      /** @description Program counter */
      pc: number;
      scratch?: Array<components['schemas']['TealValue']>;
      stack: Array<components['schemas']['TealValue']>;
    };
    /** @description DryrunTxnResult contains any LogicSig or ApplicationCall program debug information and state updates from a dryrun. */
    DryrunTxnResult: {
      'app-call-messages'?: string[];
      'app-call-trace'?: Array<components['schemas']['DryrunState']>;
      /** @description Budget added during execution of app call transaction. */
      'budget-added'?: number;
      /** @description Budget consumed during execution of app call transaction. */
      'budget-consumed'?: number;
      /** @description Disassembled program line by line. */
      disassembly: string[];
      'global-delta'?: components['schemas']['StateDelta'];
      'local-deltas'?: Array<components['schemas']['AccountStateDelta']>;
      /** @description Disassembled lsig program line by line. */
      'logic-sig-disassembly'?: string[];
      'logic-sig-messages'?: string[];
      'logic-sig-trace'?: Array<components['schemas']['DryrunState']>;
      logs?: string[];
    };
    /** @description An error response with optional data field. */
    ErrorResponse: {
      data?: Record<string, never>;
      message: string;
    };
    /** @description Represents a TEAL value delta. */
    EvalDelta: {
      /** @description \[at\] delta action. */
      action: number;
      /** @description \[bs\] bytes value. */
      bytes?: string;
      /** @description \[ui\] uint value. */
      uint?: number;
    };
    /** @description Key-value pairs for StateDelta. */
    EvalDeltaKeyValue: {
      key: string;
      value: components['schemas']['EvalDelta'];
    };
    /** @description A single Delta containing the key, the previous value and the current value for a single round. */
    KvDelta: {
      /**
       * Format: byte
       * @description The key, base64 encoded.
       */
      key?: string;
      /**
       * Format: byte
       * @description The new value of the KV store entry, base64 encoded.
       */
      value?: string;
    };
    /** @description Ledger StateDelta object */
    LedgerStateDelta: Record<string, never>;
    /** @description Contains a ledger delta for a single transaction group */
    LedgerStateDeltaForTransactionGroup: {
      Delta: components['schemas']['LedgerStateDelta'];
      Ids: string[];
    };
    /** @description Proof of membership and position of a light block header. */
    LightBlockHeaderProof: {
      /** @description The index of the light block header in the vector commitment tree */
      index: number;
      /**
       * Format: byte
       * @description The encoded proof.
       */
      proof: string;
      /** @description Represents the depth of the tree that is being proven, i.e. the number of edges from a leaf to the root. */
      treedepth: number;
    };
    /** @description Represents a participation key used by the node. */
    ParticipationKey: {
      /** @description Address the key was generated for. */
      address: string;
      /** @description When registered, this is the first round it may be used. */
      'effective-first-valid'?: number;
      /** @description When registered, this is the last round it may be used. */
      'effective-last-valid'?: number;
      /** @description The key's ParticipationID. */
      id: string;
      key: components['schemas']['AccountParticipation'];
      /** @description Round when this key was last used to propose a block. */
      'last-block-proposal'?: number;
      /** @description Round when this key was last used to generate a state proof. */
      'last-state-proof'?: number;
      /** @description Round when this key was last used to vote. */
      'last-vote'?: number;
    };
    /** @description Details about a pending transaction. If the transaction was recently confirmed, includes confirmation details like the round and reward details. */
    PendingTransactionResponse: {
      /** @description The application index if the transaction was found and it created an application. */
      'application-index'?: number;
      /** @description The number of the asset's unit that were transferred to the close-to address. */
      'asset-closing-amount'?: number;
      /** @description The asset index if the transaction was found and it created an asset. */
      'asset-index'?: number;
      /** @description Rewards in microalgos applied to the close remainder to account. */
      'close-rewards'?: number;
      /** @description Closing amount for the transaction. */
      'closing-amount'?: number;
      /** @description The round where this transaction was confirmed, if present. */
      'confirmed-round'?: number;
      'global-state-delta'?: components['schemas']['StateDelta'];
      /** @description Inner transactions produced by application execution. */
      'inner-txns'?: Array<components['schemas']['PendingTransactionResponse']>;
      /** @description Local state key/value changes for the application being executed by this transaction. */
      'local-state-delta'?: Array<components['schemas']['AccountStateDelta']>;
      /** @description Logs for the application being executed by this transaction. */
      logs?: string[];
      /** @description Indicates that the transaction was kicked out of this node's transaction pool (and specifies why that happened).  An empty string indicates the transaction wasn't kicked out of this node's txpool due to an error.
       *      */
      'pool-error': string;
      /** @description Rewards in microalgos applied to the receiver account. */
      'receiver-rewards'?: number;
      /** @description Rewards in microalgos applied to the sender account. */
      'sender-rewards'?: number;
      /** @description The raw signed transaction. */
      txn: Record<string, never>;
    };
    /** @description Request type for simulation endpoint. */
    SimulateRequest: {
      /** @description Allow transactions without signatures to be simulated as if they had correct signatures. */
      'allow-empty-signatures'?: boolean;
      /** @description Lifts limits on log opcode usage during simulation. */
      'allow-more-logging'?: boolean;
      /** @description Applies extra opcode budget during simulation for each transaction group. */
      'extra-opcode-budget'?: number;
      /** @description The transaction groups to simulate. */
      'txn-groups': Array<components['schemas']['SimulateRequestTransactionGroup']>;
    };
    /** @description A transaction group to simulate. */
    SimulateRequestTransactionGroup: {
      /** @description An atomic transaction group. */
      txns: string[];
    };
    /** @description Simulation result for an atomic transaction group */
    SimulateTransactionGroupResult: {
      /** @description Total budget added during execution of app calls in the transaction group. */
      'app-budget-added'?: number;
      /** @description Total budget consumed during execution of app calls in the transaction group. */
      'app-budget-consumed'?: number;
      /** @description If present, indicates which transaction in this group caused the failure. This array represents the path to the failing transaction. Indexes are zero based, the first element indicates the top-level transaction, and successive elements indicate deeper inner transactions. */
      'failed-at'?: number[];
      /** @description If present, indicates that the transaction group failed and specifies why that happened */
      'failure-message'?: string;
      /** @description Simulation result for individual transactions */
      'txn-results': Array<components['schemas']['SimulateTransactionResult']>;
    };
    /** @description Simulation result for an individual transaction */
    SimulateTransactionResult: {
      /** @description Budget used during execution of an app call transaction. This value includes budged used by inner app calls spawned by this transaction. */
      'app-budget-consumed'?: number;
      /** @description Budget used during execution of a logic sig transaction. */
      'logic-sig-budget-consumed'?: number;
      'txn-result': components['schemas']['PendingTransactionResponse'];
    };
    /** @description The set of parameters and limits override during simulation. If this set of parameters is present, then evaluation parameters may differ from standard evaluation in certain ways. */
    SimulationEvalOverrides: {
      /** @description If true, transactions without signatures are allowed and simulated as if they were properly signed. */
      'allow-empty-signatures'?: boolean;
      /** @description The extra opcode budget added to each transaction group during simulation */
      'extra-opcode-budget'?: number;
      /** @description The maximum log calls one can make during simulation */
      'max-log-calls'?: number;
      /** @description The maximum byte number to log during simulation */
      'max-log-size'?: number;
    };
    /** @description Application state delta. */
    StateDelta: Array<components['schemas']['EvalDeltaKeyValue']>;
    /** @description Represents a state proof and its corresponding message */
    StateProof: {
      Message: components['schemas']['StateProofMessage'];
      /**
       * Format: byte
       * @description The encoded StateProof for the message.
       */
      StateProof: string;
    };
    /** @description Represents the message that the state proofs are attesting to. */
    StateProofMessage: {
      /**
       * Format: byte
       * @description The vector commitment root on all light block headers within a state proof interval.
       */
      BlockHeadersCommitment: string;
      /** @description The first round the message attests to. */
      FirstAttestedRound: number;
      /** @description The last round the message attests to. */
      LastAttestedRound: number;
      /** @description An integer value representing the natural log of the proven weight with 16 bits of precision. This value would be used to verify the next state proof. */
      LnProvenWeight: number;
      /**
       * Format: byte
       * @description The vector commitment root of the top N accounts to sign the next StateProof.
       */
      VotersCommitment: string;
    };
    /** @description Represents a key-value pair in an application store. */
    TealKeyValue: {
      key: string;
      value: components['schemas']['TealValue'];
    };
    /** @description Represents a key-value store for use in an application. */
    TealKeyValueStore: Array<components['schemas']['TealKeyValue']>;
    /** @description Represents a TEAL value. */
    TealValue: {
      /** @description \[tb\] bytes value. */
      bytes: string;
      /** @description \[tt\] value type. Value `1` refers to **bytes**, value `2` refers to **uint** */
      type: number;
      /** @description \[ui\] uint value. */
      uint: number;
    };
    /**
     * Version contains the current algod version.
     * @description algod version information.
     */
    Version: {
      build: components['schemas']['BuildVersion'];
      /** Format: byte */
      genesis_hash_b64: string;
      genesis_id: string;
      versions: string[];
    };
  };
  responses: {
    /** @description AccountApplicationResponse describes the account's application local state and global state (AppLocalState and AppParams, if either exists) for a specific application ID. Global state will only be returned if the provided address is the application's creator. */
    AccountApplicationResponse: {
      headers: {
        [name: string]: unknown;
      };
      content: {
        'application/json': {
          'app-local-state'?: components['schemas']['ApplicationLocalState'];
          'created-app'?: components['schemas']['ApplicationParams'];
          /** @description The round for which this information is relevant. */
          round: number;
        };
      };
    };
    /** @description AccountAssetResponse describes the account's asset holding and asset parameters (if either exist) for a specific asset ID. Asset parameters will only be returned if the provided address is the asset's creator. */
    AccountAssetResponse: {
      headers: {
        [name: string]: unknown;
      };
      content: {
        'application/json': {
          'asset-holding'?: components['schemas']['AssetHolding'];
          'created-asset'?: components['schemas']['AssetParams'];
          /** @description The round for which this information is relevant. */
          round: number;
        };
      };
    };
    /** @description AccountResponse wraps the Account type in a response. */
    AccountResponse: {
      headers: {
        [name: string]: unknown;
      };
      content: {
        'application/json': components['schemas']['Account'];
      };
    };
    /** @description Application information */
    ApplicationResponse: {
      headers: {
        [name: string]: unknown;
      };
      content: {
        'application/json': components['schemas']['Application'];
      };
    };
    /** @description Asset information */
    AssetResponse: {
      headers: {
        [name: string]: unknown;
      };
      content: {
        'application/json': components['schemas']['Asset'];
      };
    };
    /** @description Hash of a block header. */
    BlockHashResponse: {
      headers: {
        [name: string]: unknown;
      };
      content: {
        'application/json': {
          /** @description Block header hash. */
          blockHash: string;
        };
      };
    };
    /** @description Encoded block object. */
    BlockResponse: {
      headers: {
        [name: string]: unknown;
      };
      content: {
        'application/json': {
          /** @description Block header data. */
          block: Record<string, never>;
          /** @description Optional certificate object. This is only included when the format is set to message pack. */
          cert?: Record<string, never>;
        };
      };
    };
    /** @description Box information */
    BoxResponse: {
      headers: {
        [name: string]: unknown;
      };
      content: {
        'application/json': components['schemas']['Box'];
      };
    };
    /** @description Box names of an application */
    BoxesResponse: {
      headers: {
        [name: string]: unknown;
      };
      content: {
        'application/json': {
          boxes: Array<components['schemas']['BoxDescriptor']>;
        };
      };
    };
    /** @description An catchpoint abort response. */
    CatchpointAbortResponse: {
      headers: {
        [name: string]: unknown;
      };
      content: {
        'application/json': {
          /** @description Catchup abort response string */
          'catchup-message': string;
        };
      };
    };
    /** @description An catchpoint start response. */
    CatchpointStartResponse: {
      headers: {
        [name: string]: unknown;
      };
      content: {
        'application/json': {
          /** @description Catchup start response string */
          'catchup-message': string;
        };
      };
    };
    /** @description Teal compile Result */
    CompileResponse: {
      headers: {
        [name: string]: unknown;
      };
      content: {
        'application/json': {
          /** @description base32 SHA512_256 of program bytes (Address style) */
          hash: string;
          /** @description base64 encoded program bytes */
          result: string;
          /** @description JSON of the source map */
          sourcemap?: Record<string, never>;
        };
      };
    };
    /** @description Teal disassembly Result */
    DisassembleResponse: {
      headers: {
        [name: string]: unknown;
      };
      content: {
        'application/json': {
          /** @description disassembled Teal code */
          result: string;
        };
      };
    };
    /** @description DryrunResponse contains per-txn debug information from a dryrun. */
    DryrunResponse: {
      headers: {
        [name: string]: unknown;
      };
      content: {
        'application/json': {
          error: string;
          /** @description Protocol version is the protocol version Dryrun was operated under. */
          'protocol-version': string;
          txns: Array<components['schemas']['DryrunTxnResult']>;
        };
      };
    };
    /** @description Response containing the timestamp offset in seconds */
    GetBlockTimeStampOffsetResponse: {
      headers: {
        [name: string]: unknown;
      };
      content: {
        'application/json': {
          /** @description Timestamp offset in seconds. */
          offset: number;
        };
      };
    };
    /** @description Response containing the ledger's minimum sync round */
    GetSyncRoundResponse: {
      headers: {
        [name: string]: unknown;
      };
      content: {
        'application/json': {
          /** @description The minimum sync round for the ledger. */
          round: number;
        };
      };
    };
    /** @description Response containing a ledger state delta for a single transaction group. */
    LedgerStateDeltaForTransactionGroupResponse: {
      headers: {
        [name: string]: unknown;
      };
      content: {
        'application/json': components['schemas']['LedgerStateDelta'];
      };
    };
    /** @description Contains ledger deltas */
    LedgerStateDeltaResponse: {
      headers: {
        [name: string]: unknown;
      };
      content: {
        'application/json': components['schemas']['LedgerStateDelta'];
      };
    };
    /** @description Proof of a light block header. */
    LightBlockHeaderProofResponse: {
      headers: {
        [name: string]: unknown;
      };
      content: {
        'application/json': components['schemas']['LightBlockHeaderProof'];
      };
    };
    /** @description NodeStatus contains the information about a node status */
    NodeStatusResponse: {
      headers: {
        [name: string]: unknown;
      };
      content: {
        'application/json': {
          /** @description The current catchpoint that is being caught up to */
          catchpoint?: string;
          /** @description The number of blocks that have already been obtained by the node as part of the catchup */
          'catchpoint-acquired-blocks'?: number;
          /** @description The number of accounts from the current catchpoint that have been processed so far as part of the catchup */
          'catchpoint-processed-accounts'?: number;
          /** @description The number of key-values (KVs) from the current catchpoint that have been processed so far as part of the catchup */
          'catchpoint-processed-kvs'?: number;
          /** @description The total number of accounts included in the current catchpoint */
          'catchpoint-total-accounts'?: number;
          /** @description The total number of blocks that are required to complete the current catchpoint catchup */
          'catchpoint-total-blocks'?: number;
          /** @description The total number of key-values (KVs) included in the current catchpoint */
          'catchpoint-total-kvs'?: number;
          /** @description The number of accounts from the current catchpoint that have been verified so far as part of the catchup */
          'catchpoint-verified-accounts'?: number;
          /** @description The number of key-values (KVs) from the current catchpoint that have been verified so far as part of the catchup */
          'catchpoint-verified-kvs'?: number;
          /** @description CatchupTime in nanoseconds */
          'catchup-time': number;
          /** @description The last catchpoint seen by the node */
          'last-catchpoint'?: string;
          /** @description LastRound indicates the last round seen */
          'last-round': number;
          /** @description LastVersion indicates the last consensus version supported */
          'last-version': string;
          /** @description NextVersion of consensus protocol to use */
          'next-version': string;
          /** @description NextVersionRound is the round at which the next consensus version will apply */
          'next-version-round': number;
          /** @description NextVersionSupported indicates whether the next consensus version is supported by this node */
          'next-version-supported': boolean;
          /** @description StoppedAtUnsupportedRound indicates that the node does not support the new rounds and has stopped making progress */
          'stopped-at-unsupported-round': boolean;
          /** @description TimeSinceLastRound in nanoseconds */
          'time-since-last-round': number;
          /** @description Upgrade delay */
          'upgrade-delay'?: number;
          /** @description Next protocol round */
          'upgrade-next-protocol-vote-before'?: number;
          /** @description No votes cast for consensus upgrade */
          'upgrade-no-votes'?: number;
          /** @description This node's upgrade vote */
          'upgrade-node-vote'?: boolean;
          /** @description Total voting rounds for current upgrade */
          'upgrade-vote-rounds'?: number;
          /** @description Total votes cast for consensus upgrade */
          'upgrade-votes'?: number;
          /** @description Yes votes required for consensus upgrade */
          'upgrade-votes-required'?: number;
          /** @description Yes votes cast for consensus upgrade */
          'upgrade-yes-votes'?: number;
        };
      };
    };
    /** @description A detailed description of a participation ID */
    ParticipationKeyResponse: {
      headers: {
        [name: string]: unknown;
      };
      content: {
        'application/json': components['schemas']['ParticipationKey'];
      };
    };
    /** @description A list of participation keys */
    ParticipationKeysResponse: {
      headers: {
        [name: string]: unknown;
      };
      content: {
        'application/json': Array<components['schemas']['ParticipationKey']>;
      };
    };
    /** @description A potentially truncated list of transactions currently in the node's transaction pool. You can compute whether or not the list is truncated if the number of elements in the **top-transactions** array is fewer than **total-transactions**. */
    PendingTransactionsResponse: {
      headers: {
        [name: string]: unknown;
      };
      content: {
        'application/json': {
          /** @description An array of signed transaction objects. */
          'top-transactions': Array<Record<string, never>>;
          /** @description Total number of transactions in the pool. */
          'total-transactions': number;
        };
      };
    };
    /** @description Participation ID of the submission */
    PostParticipationResponse: {
      headers: {
        [name: string]: unknown;
      };
      content: {
        'application/json': {
          /** @description encoding of the participation ID. */
          partId: string;
        };
      };
    };
    /** @description Transaction ID of the submission. */
    PostTransactionsResponse: {
      headers: {
        [name: string]: unknown;
      };
      content: {
        'application/json': {
          /** @description encoding of the transaction hash. */
          txId: string;
        };
      };
    };
    /** @description Result of a transaction group simulation. */
    SimulateResponse: {
      headers: {
        [name: string]: unknown;
      };
      content: {
        'application/json': {
          'eval-overrides'?: components['schemas']['SimulationEvalOverrides'];
          /** @description The round immediately preceding this simulation. State changes through this round were used to run this simulation. */
          'last-round': number;
          /** @description A result object for each transaction group that was simulated. */
          'txn-groups': Array<components['schemas']['SimulateTransactionGroupResult']>;
          /** @description The version of this response object. */
          version: number;
        };
      };
    };
    /** @description StateProofResponse wraps the StateProof type in a response. */
    StateProofResponse: {
      headers: {
        [name: string]: unknown;
      };
      content: {
        'application/json': components['schemas']['StateProof'];
      };
    };
    /** @description Supply represents the current supply of MicroAlgos in the system. */
    SupplyResponse: {
      headers: {
        [name: string]: unknown;
      };
      content: {
        'application/json': {
          /** @description Round */
          current_round: number;
          /** @description OnlineMoney */
          'online-money': number;
          /** @description TotalMoney */
          'total-money': number;
        };
      };
    };
    /** @description Response containing all ledger state deltas for transaction groups, with their associated Ids, in a single round. */
    TransactionGroupLedgerStateDeltasForRoundResponse: {
      headers: {
        [name: string]: unknown;
      };
      content: {
        'application/json': {
          Deltas: Array<components['schemas']['LedgerStateDeltaForTransactionGroup']>;
        };
      };
    };
    /** @description TransactionParams contains the parameters that help a client construct a new transaction. */
    TransactionParametersResponse: {
      headers: {
        [name: string]: unknown;
      };
      content: {
        'application/json': {
          /** @description ConsensusVersion indicates the consensus protocol version
           *     as of LastRound. */
          'consensus-version': string;
          /** @description Fee is the suggested transaction fee
           *     Fee is in units of micro-Algos per byte.
           *     Fee may fall to zero but transactions must still have a fee of
           *     at least MinTxnFee for the current network protocol. */
          fee: number;
          /**
           * Format: byte
           * @description GenesisHash is the hash of the genesis block.
           */
          'genesis-hash': string;
          /** @description GenesisID is an ID listed in the genesis block. */
          'genesis-id': string;
          /** @description LastRound indicates the last round seen */
          'last-round': number;
          /** @description The minimum transaction fee (not per byte) required for the
           *     txn to validate for the current network protocol. */
          'min-fee': number;
        };
      };
    };
    /** @description Proof of transaction in a block. */
    TransactionProofResponse: {
      headers: {
        [name: string]: unknown;
      };
      content: {
        'application/json': {
          /**
           * @description The type of hash function used to create the proof, must be one of:
           *     * sha512_256
           *     * sha256
           * @enum {string}
           */
          hashtype: 'sha512_256' | 'sha256';
          /** @description Index of the transaction in the block's payset. */
          idx: number;
          /**
           * Format: byte
           * @description Proof of transaction membership.
           */
          proof: string;
          /**
           * Format: byte
           * @description Hash of SignedTxnInBlock for verifying proof.
           */
          stibhash: string;
          /** @description Represents the depth of the tree that is being proven, i.e. the number of edges from a leaf to the root. */
          treedepth: number;
        };
      };
    };
    /** @description VersionsResponse is the response to 'GET /versions' */
    VersionsResponse: {
      headers: {
        [name: string]: unknown;
      };
      content: {
        'application/json': components['schemas']['Version'];
      };
    };
  };
  parameters: {
    /** @description account string */
    'account-id': string;
    /** @description Only include transactions with this address in one of the transaction fields. */
    address: string;
    /** @description Combine with the address parameter to define what type of address to search for. */
    'address-role': 'sender' | 'receiver' | 'freeze-target';
    /** @description Include results after the given time. Must be an RFC 3339 formatted string. */
    'after-time': string;
    /** @description Asset ID */
    'asset-id': number;
    /** @description Include results before the given time. Must be an RFC 3339 formatted string. */
    'before-time': string;
    /** @description A catch point */
    catchpoint: string;
    /** @description Results should have an amount greater than this value. MicroAlgos are the default currency unless an asset-id is provided, in which case the asset will be used. */
    'currency-greater-than': number;
    /** @description Results should have an amount less than this value. MicroAlgos are the default currency unless an asset-id is provided, in which case the asset will be used. */
    'currency-less-than': number;
    /** @description Combine with address and address-role parameters to define what type of address to search for. The close to fields are normally treated as a receiver, if you would like to exclude them set this parameter to true. */
    'exclude-close-to': boolean;
    /** @description Configures whether the response object is JSON or MessagePack encoded. If not provided, defaults to JSON. */
    format: 'json' | 'msgpack';
    /** @description Maximum number of results to return. */
    limit: number;
    /** @description Truncated number of transactions to display. If max=0, returns all pending txns. */
    max: number;
    /** @description Include results at or before the specified max-round. */
    'max-round': number;
    /** @description Include results at or after the specified min-round. */
    'min-round': number;
    /** @description The next page of results. Use the next token provided by the previous results. */
    next: string;
    /** @description Specifies a prefix which must be contained in the note field. */
    'note-prefix': string;
    /** @description Include results for the specified round. */
    round: number;
    /** @description Round number */
    'round-number': number;
    /** @description SigType filters just results using the specified type of signature:
     *     * sig - Standard
     *     * msig - MultiSig
     *     * lsig - LogicSig */
    'sig-type': 'sig' | 'msig' | 'lsig';
    /** @description Lookup the specific transaction by ID. */
    'tx-id': string;
    'tx-type': 'pay' | 'keyreg' | 'acfg' | 'axfer' | 'afrz' | 'appl' | 'stpf';
  };
  requestBodies: never;
  headers: never;
  pathItems: never;
}
export type $defs = Record<string, never>;
export interface operations {
  GetGenesis: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description The genesis file in json. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': string;
        };
      };
      /** @description Unknown Error */
      default: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  HealthCheck: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Unknown Error */
      default: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  Metrics: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description text with \#-comments and key:value lines */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description metrics were compiled out */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  GetReady: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Internal Error */
      500: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Node not ready yet */
      503: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Unknown Error */
      default: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  SwaggerJSON: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description The current swagger spec */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': string;
        };
      };
      /** @description Unknown Error */
      default: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  AccountInformation: {
    parameters: {
      query?: {
        /** @description Configures whether the response object is JSON or MessagePack encoded. If not provided, defaults to JSON. */
        format?: 'json' | 'msgpack';
        /** @description When set to `all` will exclude asset holdings, application local state, created asset parameters, any created application parameters. Defaults to `none`. */
        exclude?: 'all' | 'none';
      };
      header?: never;
      path: {
        /** @description An account public key */
        address: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description AccountResponse wraps the Account type in a response. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['Account'];
          'application/msgpack': components['schemas']['Account'];
        };
      };
      /** @description Bad request */
      400: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ErrorResponse'];
          'application/msgpack': components['schemas']['ErrorResponse'];
        };
      };
      /** @description Invalid API Token */
      401: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ErrorResponse'];
          'application/msgpack': components['schemas']['ErrorResponse'];
        };
      };
      /** @description Internal Error */
      500: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ErrorResponse'];
          'application/msgpack': components['schemas']['ErrorResponse'];
        };
      };
      /** @description Unknown Error */
      default: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  AccountApplicationInformation: {
    parameters: {
      query?: {
        /** @description Configures whether the response object is JSON or MessagePack encoded. If not provided, defaults to JSON. */
        format?: 'json' | 'msgpack';
      };
      header?: never;
      path: {
        /** @description An account public key */
        address: string;
        /** @description An application identifier */
        'application-id': number;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description AccountApplicationResponse describes the account's application local state and global state (AppLocalState and AppParams, if either exists) for a specific application ID. Global state will only be returned if the provided address is the application's creator. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': {
            'app-local-state'?: components['schemas']['ApplicationLocalState'];
            'created-app'?: components['schemas']['ApplicationParams'];
            /** @description The round for which this information is relevant. */
            round: number;
          };
          'application/msgpack': {
            'app-local-state'?: components['schemas']['ApplicationLocalState'];
            'created-app'?: components['schemas']['ApplicationParams'];
            /** @description The round for which this information is relevant. */
            round: number;
          };
        };
      };
      /** @description Malformed address or application ID */
      400: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ErrorResponse'];
          'application/msgpack': components['schemas']['ErrorResponse'];
        };
      };
      /** @description Invalid API Token */
      401: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ErrorResponse'];
          'application/msgpack': components['schemas']['ErrorResponse'];
        };
      };
      /** @description Internal Error */
      500: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ErrorResponse'];
          'application/msgpack': components['schemas']['ErrorResponse'];
        };
      };
      /** @description Unknown Error */
      default: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  AccountAssetInformation: {
    parameters: {
      query?: {
        /** @description Configures whether the response object is JSON or MessagePack encoded. If not provided, defaults to JSON. */
        format?: 'json' | 'msgpack';
      };
      header?: never;
      path: {
        /** @description An account public key */
        address: string;
        /** @description An asset identifier */
        'asset-id': number;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description AccountAssetResponse describes the account's asset holding and asset parameters (if either exist) for a specific asset ID. Asset parameters will only be returned if the provided address is the asset's creator. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': {
            'asset-holding'?: components['schemas']['AssetHolding'];
            'created-asset'?: components['schemas']['AssetParams'];
            /** @description The round for which this information is relevant. */
            round: number;
          };
          'application/msgpack': {
            'asset-holding'?: components['schemas']['AssetHolding'];
            'created-asset'?: components['schemas']['AssetParams'];
            /** @description The round for which this information is relevant. */
            round: number;
          };
        };
      };
      /** @description Malformed address or asset ID */
      400: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ErrorResponse'];
          'application/msgpack': components['schemas']['ErrorResponse'];
        };
      };
      /** @description Invalid API Token */
      401: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ErrorResponse'];
          'application/msgpack': components['schemas']['ErrorResponse'];
        };
      };
      /** @description Internal Error */
      500: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ErrorResponse'];
          'application/msgpack': components['schemas']['ErrorResponse'];
        };
      };
      /** @description Unknown Error */
      default: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  GetPendingTransactionsByAddress: {
    parameters: {
      query?: {
        /** @description Truncated number of transactions to display. If max=0, returns all pending txns. */
        max?: number;
        /** @description Configures whether the response object is JSON or MessagePack encoded. If not provided, defaults to JSON. */
        format?: 'json' | 'msgpack';
      };
      header?: never;
      path: {
        /** @description An account public key */
        address: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description A potentially truncated list of transactions currently in the node's transaction pool. You can compute whether or not the list is truncated if the number of elements in the **top-transactions** array is fewer than **total-transactions**. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': {
            /** @description An array of signed transaction objects. */
            'top-transactions': Array<Record<string, never>>;
            /** @description Total number of transactions in the pool. */
            'total-transactions': number;
          };
          'application/msgpack': {
            /** @description An array of signed transaction objects. */
            'top-transactions': Array<Record<string, never>>;
            /** @description Total number of transactions in the pool. */
            'total-transactions': number;
          };
        };
      };
      /** @description Max must be a non-negative integer */
      400: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ErrorResponse'];
          'application/msgpack': components['schemas']['ErrorResponse'];
        };
      };
      /** @description Invalid API Token */
      401: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ErrorResponse'];
          'application/msgpack': components['schemas']['ErrorResponse'];
        };
      };
      /** @description Internal Error */
      500: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ErrorResponse'];
          'application/msgpack': components['schemas']['ErrorResponse'];
        };
      };
      /** @description Service Temporarily Unavailable */
      503: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ErrorResponse'];
          'application/msgpack': components['schemas']['ErrorResponse'];
        };
      };
      /** @description Unknown Error */
      default: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  GetApplicationByID: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description An application identifier */
        'application-id': number;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Application information */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['Application'];
        };
      };
      /** @description Bad Request */
      400: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ErrorResponse'];
        };
      };
      /** @description Invalid API Token */
      401: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ErrorResponse'];
        };
      };
      /** @description Application Not Found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ErrorResponse'];
        };
      };
      /** @description Internal Error */
      500: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ErrorResponse'];
        };
      };
      /** @description Unknown Error */
      default: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  GetApplicationBoxByName: {
    parameters: {
      query: {
        /** @description A box name, in the goal app call arg form 'encoding:value'. For ints, use the form 'int:1234'. For raw bytes, use the form 'b64:A=='. For printable strings, use the form 'str:hello'. For addresses, use the form 'addr:XYZ...'. */
        name: string;
      };
      header?: never;
      path: {
        /** @description An application identifier */
        'application-id': number;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Box information */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['Box'];
        };
      };
      /** @description Bad Request */
      400: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ErrorResponse'];
        };
      };
      /** @description Invalid API Token */
      401: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ErrorResponse'];
        };
      };
      /** @description Box Not Found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ErrorResponse'];
        };
      };
      /** @description Internal Error */
      500: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ErrorResponse'];
        };
      };
      /** @description Unknown Error */
      default: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  GetApplicationBoxes: {
    parameters: {
      query?: {
        /** @description Max number of box names to return. If max is not set, or max == 0, returns all box-names. */
        max?: number;
      };
      header?: never;
      path: {
        /** @description An application identifier */
        'application-id': number;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Box names of an application */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': {
            boxes: Array<components['schemas']['BoxDescriptor']>;
          };
        };
      };
      /** @description Bad Request */
      400: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ErrorResponse'];
        };
      };
      /** @description Invalid API Token */
      401: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ErrorResponse'];
        };
      };
      /** @description Internal Error */
      500: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ErrorResponse'];
        };
      };
      /** @description Unknown Error */
      default: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  GetAssetByID: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description An asset identifier */
        'asset-id': number;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Asset information */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['Asset'];
        };
      };
      /** @description Bad Request */
      400: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ErrorResponse'];
        };
      };
      /** @description Invalid API Token */
      401: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ErrorResponse'];
        };
      };
      /** @description Application Not Found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ErrorResponse'];
        };
      };
      /** @description Internal Error */
      500: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ErrorResponse'];
        };
      };
      /** @description Unknown Error */
      default: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  GetBlock: {
    parameters: {
      query?: {
        /** @description Configures whether the response object is JSON or MessagePack encoded. If not provided, defaults to JSON. */
        format?: 'json' | 'msgpack';
      };
      header?: never;
      path: {
        /** @description The round from which to fetch block information. */
        round: number;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Encoded block object. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': {
            /** @description Block header data. */
            block: Record<string, never>;
            /** @description Optional certificate object. This is only included when the format is set to message pack. */
            cert?: Record<string, never>;
          };
          'application/msgpack': {
            /** @description Block header data. */
            block: Record<string, never>;
            /** @description Optional certificate object. This is only included when the format is set to message pack. */
            cert?: Record<string, never>;
          };
        };
      };
      /** @description Bad Request - Non integer number */
      400: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ErrorResponse'];
          'application/msgpack': components['schemas']['ErrorResponse'];
        };
      };
      /** @description Invalid API Token */
      401: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ErrorResponse'];
          'application/msgpack': components['schemas']['ErrorResponse'];
        };
      };
      /** @description None existing block  */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ErrorResponse'];
          'application/msgpack': components['schemas']['ErrorResponse'];
        };
      };
      /** @description Internal Error */
      500: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ErrorResponse'];
          'application/msgpack': components['schemas']['ErrorResponse'];
        };
      };
      /** @description Unknown Error */
      default: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  GetBlockHash: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The round from which to fetch block hash information. */
        round: number;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Hash of a block header. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': {
            /** @description Block header hash. */
            blockHash: string;
          };
        };
      };
      /** @description Bad Request - Non integer number */
      400: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ErrorResponse'];
        };
      };
      /** @description Invalid API Token */
      401: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ErrorResponse'];
        };
      };
      /** @description None existing block  */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ErrorResponse'];
        };
      };
      /** @description Internal Error */
      500: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ErrorResponse'];
        };
      };
      /** @description Unknown Error */
      default: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  GetLightBlockHeaderProof: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The round to which the light block header belongs. */
        round: number;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Proof of a light block header. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['LightBlockHeaderProof'];
        };
      };
      /** @description Invalid API Token */
      401: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ErrorResponse'];
        };
      };
      /** @description Could not create proof since some data is missing */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ErrorResponse'];
        };
      };
      /** @description timed out on request */
      408: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ErrorResponse'];
        };
      };
      /** @description Internal Error */
      500: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ErrorResponse'];
        };
      };
      /** @description Service Temporarily Unavailable */
      503: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ErrorResponse'];
        };
      };
      /** @description Unknown Error */
      default: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  GetTransactionProof: {
    parameters: {
      query?: {
        /** @description The type of hash function used to create the proof, must be one of:
         *     * sha512_256
         *     * sha256 */
        hashtype?: 'sha512_256' | 'sha256';
        /** @description Configures whether the response object is JSON or MessagePack encoded. If not provided, defaults to JSON. */
        format?: 'json' | 'msgpack';
      };
      header?: never;
      path: {
        /** @description The round in which the transaction appears. */
        round: number;
        /** @description The transaction ID for which to generate a proof. */
        txid: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Proof of transaction in a block. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': {
            /**
             * @description The type of hash function used to create the proof, must be one of:
             *     * sha512_256
             *     * sha256
             * @enum {string}
             */
            hashtype: 'sha512_256' | 'sha256';
            /** @description Index of the transaction in the block's payset. */
            idx: number;
            /**
             * Format: byte
             * @description Proof of transaction membership.
             */
            proof: string;
            /**
             * Format: byte
             * @description Hash of SignedTxnInBlock for verifying proof.
             */
            stibhash: string;
            /** @description Represents the depth of the tree that is being proven, i.e. the number of edges from a leaf to the root. */
            treedepth: number;
          };
        };
      };
      /** @description Malformed round number or transaction ID */
      400: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ErrorResponse'];
        };
      };
      /** @description Invalid API token */
      401: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ErrorResponse'];
        };
      };
      /** @description Non-existent block or transaction */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ErrorResponse'];
        };
      };
      /** @description Internal error, including protocol not supporting proofs. */
      500: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ErrorResponse'];
        };
      };
      /** @description Unknown error */
      default: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  StartCatchup: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description A catch point */
        catchpoint: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description An catchpoint start response. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': {
            /** @description Catchup start response string */
            'catchup-message': string;
          };
        };
      };
      /** @description An catchpoint start response. */
      201: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': {
            /** @description Catchup start response string */
            'catchup-message': string;
          };
        };
      };
      /** @description Bad Request */
      400: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ErrorResponse'];
        };
      };
      /** @description Invalid API Token */
      401: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ErrorResponse'];
        };
      };
      /** @description Internal Error */
      500: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ErrorResponse'];
        };
      };
      /** @description Unknown Error */
      default: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  AbortCatchup: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description A catch point */
        catchpoint: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description An catchpoint abort response. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': {
            /** @description Catchup abort response string */
            'catchup-message': string;
          };
        };
      };
      /** @description Bad Request */
      400: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ErrorResponse'];
        };
      };
      /** @description Invalid API Token */
      401: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ErrorResponse'];
        };
      };
      /** @description Internal Error */
      500: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ErrorResponse'];
        };
      };
      /** @description Unknown Error */
      default: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  GetLedgerStateDeltaForTransactionGroup: {
    parameters: {
      query?: {
        /** @description Configures whether the response object is JSON or MessagePack encoded. If not provided, defaults to JSON. */
        format?: 'json' | 'msgpack';
      };
      header?: never;
      path: {
        /** @description A transaction ID, or transaction group ID */
        id: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Response containing a ledger state delta for a single transaction group. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['LedgerStateDelta'];
          'application/msgpack': components['schemas']['LedgerStateDelta'];
        };
      };
      /** @description Invalid API Token */
      401: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ErrorResponse'];
          'application/msgpack': components['schemas']['ErrorResponse'];
        };
      };
      /** @description Could not find a delta for transaction ID or group ID */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ErrorResponse'];
          'application/msgpack': components['schemas']['ErrorResponse'];
        };
      };
      /** @description timed out on request */
      408: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ErrorResponse'];
          'application/msgpack': components['schemas']['ErrorResponse'];
        };
      };
      /** @description Internal Error */
      500: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ErrorResponse'];
          'application/msgpack': components['schemas']['ErrorResponse'];
        };
      };
      /** @description Not Implemented */
      501: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ErrorResponse'];
          'application/msgpack': components['schemas']['ErrorResponse'];
        };
      };
      /** @description Unknown Error */
      default: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  GetLedgerStateDelta: {
    parameters: {
      query?: {
        /** @description Configures whether the response object is JSON or MessagePack encoded. If not provided, defaults to JSON. */
        format?: 'json' | 'msgpack';
      };
      header?: never;
      path: {
        /** @description The round for which the deltas are desired. */
        round: number;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Contains ledger deltas */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['LedgerStateDelta'];
          'application/msgpack': components['schemas']['LedgerStateDelta'];
        };
      };
      /** @description Invalid API Token */
      401: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ErrorResponse'];
          'application/msgpack': components['schemas']['ErrorResponse'];
        };
      };
      /** @description Could not find a delta for round */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ErrorResponse'];
          'application/msgpack': components['schemas']['ErrorResponse'];
        };
      };
      /** @description timed out on request */
      408: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ErrorResponse'];
          'application/msgpack': components['schemas']['ErrorResponse'];
        };
      };
      /** @description Internal Error */
      500: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ErrorResponse'];
          'application/msgpack': components['schemas']['ErrorResponse'];
        };
      };
      /** @description Service Temporarily Unavailable */
      503: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ErrorResponse'];
          'application/msgpack': components['schemas']['ErrorResponse'];
        };
      };
      /** @description Unknown Error */
      default: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  GetTransactionGroupLedgerStateDeltasForRound: {
    parameters: {
      query?: {
        /** @description Configures whether the response object is JSON or MessagePack encoded. If not provided, defaults to JSON. */
        format?: 'json' | 'msgpack';
      };
      header?: never;
      path: {
        /** @description The round for which the deltas are desired. */
        round: number;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Response containing all ledger state deltas for transaction groups, with their associated Ids, in a single round. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': {
            Deltas: Array<components['schemas']['LedgerStateDeltaForTransactionGroup']>;
          };
          'application/msgpack': {
            Deltas: Array<components['schemas']['LedgerStateDeltaForTransactionGroup']>;
          };
        };
      };
      /** @description Invalid API Token */
      401: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ErrorResponse'];
          'application/msgpack': components['schemas']['ErrorResponse'];
        };
      };
      /** @description Could not find deltas for round */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ErrorResponse'];
          'application/msgpack': components['schemas']['ErrorResponse'];
        };
      };
      /** @description timed out on request */
      408: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ErrorResponse'];
          'application/msgpack': components['schemas']['ErrorResponse'];
        };
      };
      /** @description Internal Error */
      500: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ErrorResponse'];
          'application/msgpack': components['schemas']['ErrorResponse'];
        };
      };
      /** @description Not Implemented */
      501: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ErrorResponse'];
          'application/msgpack': components['schemas']['ErrorResponse'];
        };
      };
      /** @description Unknown Error */
      default: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  GetBlockTimeStampOffset: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Response containing the timestamp offset in seconds */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': {
            /** @description Timestamp offset in seconds. */
            offset: number;
          };
        };
      };
      /** @description TimeStamp offset not set. */
      400: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ErrorResponse'];
        };
      };
      /** @description Unknown Error */
      default: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  SetBlockTimeStampOffset: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The timestamp offset for blocks in dev mode. */
        offset: number;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Cannot set timestamp offset to a negative integer. */
      400: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ErrorResponse'];
        };
      };
      /** @description Invalid API Token */
      401: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ErrorResponse'];
        };
      };
      /** @description Internal Error */
      500: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ErrorResponse'];
        };
      };
      /** @description Unknown Error */
      default: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  ExperimentalCheck: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Experimental API enabled */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Experimental API not enabled */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Unknown Error */
      default: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  GetSupply: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Supply represents the current supply of MicroAlgos in the system. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': {
            /** @description Round */
            current_round: number;
            /** @description OnlineMoney */
            'online-money': number;
            /** @description TotalMoney */
            'total-money': number;
          };
        };
      };
      /** @description Invalid API Token */
      401: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ErrorResponse'];
        };
      };
      /** @description Unknown Error */
      default: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  GetSyncRound: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Response containing the ledger's minimum sync round */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': {
            /** @description The minimum sync round for the ledger. */
            round: number;
          };
        };
      };
      /** @description Sync round not set. */
      400: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ErrorResponse'];
        };
      };
      /** @description Invalid API Token */
      401: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ErrorResponse'];
        };
      };
      /** @description Internal Error */
      500: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ErrorResponse'];
        };
      };
      /** @description Service Temporarily Unavailable */
      503: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ErrorResponse'];
        };
      };
      /** @description Unknown Error */
      default: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  UnsetSyncRound: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Sync round not set. */
      400: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ErrorResponse'];
        };
      };
      /** @description Invalid API Token */
      401: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ErrorResponse'];
        };
      };
      /** @description Internal Error */
      500: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ErrorResponse'];
        };
      };
      /** @description Service Temporarily Unavailable */
      503: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ErrorResponse'];
        };
      };
      /** @description Unknown Error */
      default: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  SetSyncRound: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The round for which the deltas are desired. */
        round: number;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Can not set sync round to an earlier round than the current round. */
      400: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ErrorResponse'];
        };
      };
      /** @description Invalid API Token */
      401: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ErrorResponse'];
        };
      };
      /** @description Internal Error */
      500: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ErrorResponse'];
        };
      };
      /** @description Service Temporarily Unavailable */
      503: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ErrorResponse'];
        };
      };
      /** @description Unknown Error */
      default: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  GetParticipationKeys: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description A list of participation keys */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': Array<components['schemas']['ParticipationKey']>;
        };
      };
      /** @description Bad Request */
      400: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ErrorResponse'];
        };
      };
      /** @description Invalid API Token */
      401: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ErrorResponse'];
        };
      };
      /** @description Participation Key Not Found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ErrorResponse'];
        };
      };
      /** @description Internal Error */
      500: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ErrorResponse'];
        };
      };
      /** @description Unknown Error */
      default: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  AddParticipationKey: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** @description The participation key to add to the node */
    requestBody: {
      content: {
        'application/msgpack': string;
      };
    };
    responses: {
      /** @description Participation ID of the submission */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': {
            /** @description encoding of the participation ID. */
            partId: string;
          };
        };
      };
      /** @description Bad Request */
      400: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ErrorResponse'];
        };
      };
      /** @description Invalid API Token */
      401: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ErrorResponse'];
        };
      };
      /** @description Participation Key Not Found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ErrorResponse'];
        };
      };
      /** @description Internal Error */
      500: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ErrorResponse'];
        };
      };
      /** @description Service Temporarily Unavailable */
      503: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ErrorResponse'];
        };
      };
      /** @description Unknown Error */
      default: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  GetParticipationKeyByID: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        'participation-id': string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description A detailed description of a participation ID */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ParticipationKey'];
        };
      };
      /** @description Bad Request */
      400: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ErrorResponse'];
        };
      };
      /** @description Invalid API Token */
      401: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ErrorResponse'];
        };
      };
      /** @description Participation Key Not Found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ErrorResponse'];
        };
      };
      /** @description Internal Error */
      500: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ErrorResponse'];
        };
      };
      /** @description Unknown Error */
      default: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  AppendKeys: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        'participation-id': string;
      };
      cookie?: never;
    };
    /** @description The state proof keys to add to an existing participation ID */
    requestBody: {
      content: {
        'application/msgpack': string;
      };
    };
    responses: {
      /** @description A detailed description of a participation ID */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ParticipationKey'];
        };
      };
      /** @description Bad Request */
      400: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ErrorResponse'];
        };
      };
      /** @description Invalid API Token */
      401: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ErrorResponse'];
        };
      };
      /** @description Participation Key Not Found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ErrorResponse'];
        };
      };
      /** @description Internal Error */
      500: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ErrorResponse'];
        };
      };
      /** @description Unknown Error */
      default: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  DeleteParticipationKeyByID: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        'participation-id': string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Participation key got deleted by ID */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Bad Request */
      400: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ErrorResponse'];
        };
      };
      /** @description Invalid API Token */
      401: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ErrorResponse'];
        };
      };
      /** @description Participation Key Not Found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ErrorResponse'];
        };
      };
      /** @description Internal Error */
      500: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ErrorResponse'];
        };
      };
      /** @description Unknown Error */
      default: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  ShutdownNode: {
    parameters: {
      query?: {
        timeout?: number;
      };
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': Record<string, never>;
        };
      };
    };
  };
  GetStateProof: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The round for which a state proof is desired. */
        round: number;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description StateProofResponse wraps the StateProof type in a response. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['StateProof'];
        };
      };
      /** @description Invalid API Token */
      401: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ErrorResponse'];
        };
      };
      /** @description Could not find a state proof that covers a given round */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ErrorResponse'];
        };
      };
      /** @description timed out on request */
      408: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ErrorResponse'];
        };
      };
      /** @description Internal Error */
      500: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ErrorResponse'];
        };
      };
      /** @description Service Temporarily Unavailable */
      503: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ErrorResponse'];
        };
      };
      /** @description Unknown Error */
      default: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  GetStatus: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description NodeStatus contains the information about a node status */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': {
            /** @description The current catchpoint that is being caught up to */
            catchpoint?: string;
            /** @description The number of blocks that have already been obtained by the node as part of the catchup */
            'catchpoint-acquired-blocks'?: number;
            /** @description The number of accounts from the current catchpoint that have been processed so far as part of the catchup */
            'catchpoint-processed-accounts'?: number;
            /** @description The number of key-values (KVs) from the current catchpoint that have been processed so far as part of the catchup */
            'catchpoint-processed-kvs'?: number;
            /** @description The total number of accounts included in the current catchpoint */
            'catchpoint-total-accounts'?: number;
            /** @description The total number of blocks that are required to complete the current catchpoint catchup */
            'catchpoint-total-blocks'?: number;
            /** @description The total number of key-values (KVs) included in the current catchpoint */
            'catchpoint-total-kvs'?: number;
            /** @description The number of accounts from the current catchpoint that have been verified so far as part of the catchup */
            'catchpoint-verified-accounts'?: number;
            /** @description The number of key-values (KVs) from the current catchpoint that have been verified so far as part of the catchup */
            'catchpoint-verified-kvs'?: number;
            /** @description CatchupTime in nanoseconds */
            'catchup-time': number;
            /** @description The last catchpoint seen by the node */
            'last-catchpoint'?: string;
            /** @description LastRound indicates the last round seen */
            'last-round': number;
            /** @description LastVersion indicates the last consensus version supported */
            'last-version': string;
            /** @description NextVersion of consensus protocol to use */
            'next-version': string;
            /** @description NextVersionRound is the round at which the next consensus version will apply */
            'next-version-round': number;
            /** @description NextVersionSupported indicates whether the next consensus version is supported by this node */
            'next-version-supported': boolean;
            /** @description StoppedAtUnsupportedRound indicates that the node does not support the new rounds and has stopped making progress */
            'stopped-at-unsupported-round': boolean;
            /** @description TimeSinceLastRound in nanoseconds */
            'time-since-last-round': number;
            /** @description Upgrade delay */
            'upgrade-delay'?: number;
            /** @description Next protocol round */
            'upgrade-next-protocol-vote-before'?: number;
            /** @description No votes cast for consensus upgrade */
            'upgrade-no-votes'?: number;
            /** @description This node's upgrade vote */
            'upgrade-node-vote'?: boolean;
            /** @description Total voting rounds for current upgrade */
            'upgrade-vote-rounds'?: number;
            /** @description Total votes cast for consensus upgrade */
            'upgrade-votes'?: number;
            /** @description Yes votes required for consensus upgrade */
            'upgrade-votes-required'?: number;
            /** @description Yes votes cast for consensus upgrade */
            'upgrade-yes-votes'?: number;
          };
        };
      };
      /** @description Invalid API Token */
      401: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ErrorResponse'];
        };
      };
      /** @description Internal Error */
      500: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': string;
        };
      };
      /** @description Unknown Error */
      default: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  WaitForBlock: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The round to wait until returning status */
        round: number;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description NodeStatus contains the information about a node status */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': {
            /** @description The current catchpoint that is being caught up to */
            catchpoint?: string;
            /** @description The number of blocks that have already been obtained by the node as part of the catchup */
            'catchpoint-acquired-blocks'?: number;
            /** @description The number of accounts from the current catchpoint that have been processed so far as part of the catchup */
            'catchpoint-processed-accounts'?: number;
            /** @description The number of key-values (KVs) from the current catchpoint that have been processed so far as part of the catchup */
            'catchpoint-processed-kvs'?: number;
            /** @description The total number of accounts included in the current catchpoint */
            'catchpoint-total-accounts'?: number;
            /** @description The total number of blocks that are required to complete the current catchpoint catchup */
            'catchpoint-total-blocks'?: number;
            /** @description The total number of key-values (KVs) included in the current catchpoint */
            'catchpoint-total-kvs'?: number;
            /** @description The number of accounts from the current catchpoint that have been verified so far as part of the catchup */
            'catchpoint-verified-accounts'?: number;
            /** @description The number of key-values (KVs) from the current catchpoint that have been verified so far as part of the catchup */
            'catchpoint-verified-kvs'?: number;
            /** @description CatchupTime in nanoseconds */
            'catchup-time': number;
            /** @description The last catchpoint seen by the node */
            'last-catchpoint'?: string;
            /** @description LastRound indicates the last round seen */
            'last-round': number;
            /** @description LastVersion indicates the last consensus version supported */
            'last-version': string;
            /** @description NextVersion of consensus protocol to use */
            'next-version': string;
            /** @description NextVersionRound is the round at which the next consensus version will apply */
            'next-version-round': number;
            /** @description NextVersionSupported indicates whether the next consensus version is supported by this node */
            'next-version-supported': boolean;
            /** @description StoppedAtUnsupportedRound indicates that the node does not support the new rounds and has stopped making progress */
            'stopped-at-unsupported-round': boolean;
            /** @description TimeSinceLastRound in nanoseconds */
            'time-since-last-round': number;
            /** @description Upgrade delay */
            'upgrade-delay'?: number;
            /** @description Next protocol round */
            'upgrade-next-protocol-vote-before'?: number;
            /** @description No votes cast for consensus upgrade */
            'upgrade-no-votes'?: number;
            /** @description This node's upgrade vote */
            'upgrade-node-vote'?: boolean;
            /** @description Total voting rounds for current upgrade */
            'upgrade-vote-rounds'?: number;
            /** @description Total votes cast for consensus upgrade */
            'upgrade-votes'?: number;
            /** @description Yes votes required for consensus upgrade */
            'upgrade-votes-required'?: number;
            /** @description Yes votes cast for consensus upgrade */
            'upgrade-yes-votes'?: number;
          };
        };
      };
      /** @description Bad Request -- number must be non-negative integer  */
      400: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ErrorResponse'];
        };
      };
      /** @description Invalid API Token */
      401: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ErrorResponse'];
        };
      };
      /** @description Internal Error */
      500: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ErrorResponse'];
        };
      };
      /** @description Service Temporarily Unavailable */
      503: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ErrorResponse'];
        };
      };
      /** @description Unknown Error */
      default: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  TealCompile: {
    parameters: {
      query?: {
        /** @description When set to `true`, returns the source map of the program as a JSON. Defaults to `false`. */
        sourcemap?: boolean;
      };
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** @description TEAL source code to be compiled */
    requestBody: {
      content: {
        'text/plain': string;
      };
    };
    responses: {
      /** @description Teal compile Result */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': {
            /** @description base32 SHA512_256 of program bytes (Address style) */
            hash: string;
            /** @description base64 encoded program bytes */
            result: string;
            /** @description JSON of the source map */
            sourcemap?: Record<string, never>;
          };
        };
      };
      /** @description Bad Request - Teal Compile Error */
      400: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ErrorResponse'];
        };
      };
      /** @description Invalid API Token */
      401: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ErrorResponse'];
        };
      };
      /** @description Developer API not enabled */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Internal Error */
      500: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ErrorResponse'];
        };
      };
      /** @description Unknown Error */
      default: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  TealDisassemble: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** @description TEAL program binary to be disassembled */
    requestBody: {
      content: {
        'application/x-binary': string;
      };
    };
    responses: {
      /** @description Teal disassembly Result */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': {
            /** @description disassembled Teal code */
            result: string;
          };
        };
      };
      /** @description Bad Request - Teal Compile Error */
      400: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ErrorResponse'];
        };
      };
      /** @description Invalid API Token */
      401: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ErrorResponse'];
        };
      };
      /** @description Developer API not enabled */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Internal Error */
      500: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ErrorResponse'];
        };
      };
      /** @description Unknown Error */
      default: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  TealDryrun: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** @description Transaction (or group) and any accompanying state-simulation data. */
    requestBody?: {
      content: {
        'application/json': components['schemas']['DryrunRequest'];
        'application/msgpack': components['schemas']['DryrunRequest'];
      };
    };
    responses: {
      /** @description DryrunResponse contains per-txn debug information from a dryrun. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': {
            error: string;
            /** @description Protocol version is the protocol version Dryrun was operated under. */
            'protocol-version': string;
            txns: Array<components['schemas']['DryrunTxnResult']>;
          };
        };
      };
      /** @description Bad Request */
      400: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ErrorResponse'];
        };
      };
      /** @description Invalid API Token */
      401: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ErrorResponse'];
        };
      };
      /** @description Developer API not enabled */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Internal Error */
      500: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ErrorResponse'];
        };
      };
      /** @description Unknown Error */
      default: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  RawTransaction: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** @description The byte encoded signed transaction to broadcast to network */
    requestBody: {
      content: {
        'application/x-binary': string;
      };
    };
    responses: {
      /** @description Transaction ID of the submission. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': {
            /** @description encoding of the transaction hash. */
            txId: string;
          };
        };
      };
      /** @description Bad Request - Malformed Algorand transaction  */
      400: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ErrorResponse'];
        };
      };
      /** @description Invalid API Token */
      401: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ErrorResponse'];
        };
      };
      /** @description Internal Error */
      500: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ErrorResponse'];
        };
      };
      /** @description Service Temporarily Unavailable */
      503: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ErrorResponse'];
        };
      };
      /** @description Unknown Error */
      default: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  TransactionParams: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description TransactionParams contains the parameters that help a client construct a new transaction. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': {
            /** @description ConsensusVersion indicates the consensus protocol version
             *     as of LastRound. */
            'consensus-version': string;
            /** @description Fee is the suggested transaction fee
             *     Fee is in units of micro-Algos per byte.
             *     Fee may fall to zero but transactions must still have a fee of
             *     at least MinTxnFee for the current network protocol. */
            fee: number;
            /**
             * Format: byte
             * @description GenesisHash is the hash of the genesis block.
             */
            'genesis-hash': string;
            /** @description GenesisID is an ID listed in the genesis block. */
            'genesis-id': string;
            /** @description LastRound indicates the last round seen */
            'last-round': number;
            /** @description The minimum transaction fee (not per byte) required for the
             *     txn to validate for the current network protocol. */
            'min-fee': number;
          };
        };
      };
      /** @description Invalid API Token */
      401: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ErrorResponse'];
        };
      };
      /** @description Internal Error */
      500: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ErrorResponse'];
        };
      };
      /** @description Service Temporarily Unavailable */
      503: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ErrorResponse'];
        };
      };
      /** @description Unknown Error */
      default: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  GetPendingTransactions: {
    parameters: {
      query?: {
        /** @description Truncated number of transactions to display. If max=0, returns all pending txns. */
        max?: number;
        /** @description Configures whether the response object is JSON or MessagePack encoded. If not provided, defaults to JSON. */
        format?: 'json' | 'msgpack';
      };
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description A potentially truncated list of transactions currently in the node's transaction pool. You can compute whether or not the list is truncated if the number of elements in the **top-transactions** array is fewer than **total-transactions**. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': {
            /** @description An array of signed transaction objects. */
            'top-transactions': Array<Record<string, never>>;
            /** @description Total number of transactions in the pool. */
            'total-transactions': number;
          };
          'application/msgpack': {
            /** @description An array of signed transaction objects. */
            'top-transactions': Array<Record<string, never>>;
            /** @description Total number of transactions in the pool. */
            'total-transactions': number;
          };
        };
      };
      /** @description Invalid API Token */
      401: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ErrorResponse'];
          'application/msgpack': components['schemas']['ErrorResponse'];
        };
      };
      /** @description Internal Error */
      500: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ErrorResponse'];
          'application/msgpack': components['schemas']['ErrorResponse'];
        };
      };
      /** @description Service Temporarily Unavailable */
      503: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ErrorResponse'];
          'application/msgpack': components['schemas']['ErrorResponse'];
        };
      };
      /** @description Unknown Error */
      default: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  PendingTransactionInformation: {
    parameters: {
      query?: {
        /** @description Configures whether the response object is JSON or MessagePack encoded. If not provided, defaults to JSON. */
        format?: 'json' | 'msgpack';
      };
      header?: never;
      path: {
        /** @description A transaction ID */
        txid: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Given a transaction ID of a recently submitted transaction, it returns information about it.  There are several cases when this might succeed:
       *     - transaction committed (committed round > 0)
       *     - transaction still in the pool (committed round = 0, pool error = "")
       *     - transaction removed from pool due to error (committed round = 0, pool error != "")
       *
       *     Or the transaction may have happened sufficiently long ago that the node no longer remembers it, and this will return an error. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['PendingTransactionResponse'];
          'application/msgpack': components['schemas']['PendingTransactionResponse'];
        };
      };
      /** @description Bad Request */
      400: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ErrorResponse'];
          'application/msgpack': components['schemas']['ErrorResponse'];
        };
      };
      /** @description Invalid API Token */
      401: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ErrorResponse'];
          'application/msgpack': components['schemas']['ErrorResponse'];
        };
      };
      /** @description Transaction Not Found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ErrorResponse'];
          'application/msgpack': components['schemas']['ErrorResponse'];
        };
      };
      /** @description Unknown Error */
      default: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  SimulateTransaction: {
    parameters: {
      query?: {
        /** @description Configures whether the response object is JSON or MessagePack encoded. If not provided, defaults to JSON. */
        format?: 'json' | 'msgpack';
      };
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** @description The transactions to simulate, along with any other inputs. */
    requestBody: {
      content: {
        'application/json': components['schemas']['SimulateRequest'];
        'application/msgpack': components['schemas']['SimulateRequest'];
      };
    };
    responses: {
      /** @description Result of a transaction group simulation. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': {
            'eval-overrides'?: components['schemas']['SimulationEvalOverrides'];
            /** @description The round immediately preceding this simulation. State changes through this round were used to run this simulation. */
            'last-round': number;
            /** @description A result object for each transaction group that was simulated. */
            'txn-groups': Array<components['schemas']['SimulateTransactionGroupResult']>;
            /** @description The version of this response object. */
            version: number;
          };
          'application/msgpack': {
            'eval-overrides'?: components['schemas']['SimulationEvalOverrides'];
            /** @description The round immediately preceding this simulation. State changes through this round were used to run this simulation. */
            'last-round': number;
            /** @description A result object for each transaction group that was simulated. */
            'txn-groups': Array<components['schemas']['SimulateTransactionGroupResult']>;
            /** @description The version of this response object. */
            version: number;
          };
        };
      };
      /** @description Bad Request */
      400: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ErrorResponse'];
          'application/msgpack': components['schemas']['ErrorResponse'];
        };
      };
      /** @description Invalid API Token */
      401: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ErrorResponse'];
          'application/msgpack': components['schemas']['ErrorResponse'];
        };
      };
      /** @description Internal Error */
      500: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ErrorResponse'];
          'application/msgpack': components['schemas']['ErrorResponse'];
        };
      };
      /** @description Service Temporarily Unavailable */
      503: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ErrorResponse'];
          'application/msgpack': components['schemas']['ErrorResponse'];
        };
      };
      /** @description Unknown Error */
      default: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  GetVersion: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description VersionsResponse is the response to 'GET /versions' */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['Version'];
        };
      };
    };
  };
}
